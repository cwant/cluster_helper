#!/usr/bin/env ruby

require_relative '../lib/cluster_helper'
require_relative '../lib/cluster_helper/monkey_patch/hash_stringify_keys'
require 'readline'

class JobConsole < ClusterHelper::BaseReportProgram

  ACCOUNT_COMMANDS = ['account', 'accounts', 'a'].freeze
  JOB_COMMANDS = ['job', 'jobs', 'j'].freeze
  RELOAD_COMMANDS = ['reload', 'r'].freeze
  FORMAT_COMMANDS = ['format', 'f'].freeze
  QUIT_COMMANDS = ['quit', 'exit', 'q'].freeze
  HELP_COMMANDS = ['help', 'h', '?'].freeze
  USER_COMMANDS = ['user', 'u'].freeze
  SETTINGS_COMMANDS = ['settings', 's'].freeze

  COMMANDS = (ACCOUNT_COMMANDS +
              JOB_COMMANDS +
              RELOAD_COMMANDS +
              FORMAT_COMMANDS +
              QUIT_COMMANDS +
              HELP_COMMANDS +
              SETTINGS_COMMANDS +
              USER_COMMANDS).freeze

  NAME_SUBCOMMANDS = ['name', 'names', 'n'].freeze
  MEMBER_SUBCOMMANDS = ['member', 'members', 'm'].freeze

  SHOW_ALL_SUBCOMMANDS = ['all', nil].freeze

  ACTIVE_STATE_SUBCOMMANDS = ['pending',
                              'running'].freeze
  INACTIVE_STATE_SUBCOMMANDS = ['inactive',
                                'completed'].freeze
  STATE_SUBCOMMANDS = (ACTIVE_STATE_SUBCOMMANDS +
                       INACTIVE_STATE_SUBCOMMANDS).freeze
  COUNT_SUBCOMMANDS = ['count'].freeze

  ACCOUNT_SUBCOMMANDS = (NAME_SUBCOMMANDS +
                         MEMBER_SUBCOMMANDS).freeze
  JOB_SUBCOMMANDS = (SHOW_ALL_SUBCOMMANDS +
                     STATE_SUBCOMMANDS +
                     COUNT_SUBCOMMANDS).freeze
  FORMAT_SUBCOMMANDS = ['json', 'yaml', 'compact_json'].freeze

  SUBCOMMANDS = (ACCOUNT_SUBCOMMANDS +
                 JOB_SUBCOMMANDS +
                 FORMAT_SUBCOMMANDS).freeze

  AUTOCOMPLETE = (COMMANDS + SUBCOMMANDS)
                 .select { |c| c && c.length > 1 }.uniq.freeze

  config_option :user
  config_option :json
  config_option :compact_json
  config_option :yaml

  config_option :command

  private

  def options_command(opts)
    opts.on('-c', '--command COMMAND', 'Run command and exit') do |v|
      @options[:command] = v
    end
  end

  def print_help
    puts 'Some things to try:'
    puts '  jobs'
    puts '  jobs count'
    puts '  job 1112222333'
    puts '  jobs running (or pending, inactive, completed, etc)'
    puts '  jobs inactive (anything not pending or running)'
    puts '  jobs inactive count'
    puts '  accounts'
    puts '  account members'
    puts '  account def-howdy (or just match start of account name)'
    puts '  format json (default format yaml)'
    puts '  help'
    puts 'Press Ctrl-D to exit.'
  end
  alias help print_help

  def main
    return single_command(@options[:command]) if @options[:command]

    print_help
    command_loop
  end

  def single_command(input)
    bnd = binding()
    input_to_commands(input).each do |command|
      break unless command
      bnd.eval command
    end
  end

  def settings
    render(settings: { user: user.username,
                       format: format })
  end

  def command_loop
    comp = proc { |s| AUTOCOMPLETE.grep(/^#{Regexp.escape(s)}/) }

    Readline.completion_append_character = ' '
    Readline.completion_proc = comp

    bnd = binding()
    while (input = Readline.readline(prompt, true))
      begin
        input_to_commands(input).each do |command|
          return nil unless command
          bnd.eval command
        end
      rescue UnknownOption => e
        puts "Bad option #{e.message} (type 'help' for assistance)"
      rescue ClusterHelper::BaseReportProgram::UnknownFormat => e
        puts "Bad format #{e.message} (type 'help' for assistance)"
      rescue NameError => e
        puts "Bad command #{e.message} (type 'help' for assistance)"
      rescue StandardError => e
        puts "Error (#{e.class}) (type 'help' for assistance)"
      end
    end
    puts ''
  end

  def input_to_commands(input)
    input.strip.split(';').map { |i| sanitize_input(i) }
  end

  def sanitize_input(input)
    parts = input.split(' ')
    method = parts[0].strip.downcase

    if JOB_COMMANDS.include?(method)
      method = 'job'
    elsif ACCOUNT_COMMANDS.include?(method)
      method = 'account'
    elsif RELOAD_COMMANDS.include?(method)
      method = 'reload'
    elsif HELP_COMMANDS.include?(method)
      method = 'help'
    elsif FORMAT_COMMANDS.include?(method)
      method = 'use_format'
    elsif USER_COMMANDS.include?(method)
      method = 'switch_user'
    elsif SETTINGS_COMMANDS.include?(method)
      method = 'settings'
    elsif QUIT_COMMANDS.include?(method)
      return nil
    elsif JOB_SUBCOMMANDS.include?(method)
      parts = ['job'] + parts
      method = 'job'
    elsif ACCOUNT_SUBCOMMANDS.include?(method)
      parts = ['account'] + parts
      method = 'account'
    elsif FORMAT_SUBCOMMANDS.include?(method)
      parts = ['format'] + parts
      method = 'use_format'
    else
      raise NameError, method
    end

    args = parts[1..-1].map { |value| "'#{value}'" }

    "#{method} #{args.join(', ')}"
  end

  def prompt
    "job_console(#{user.username})> "
  end

  def job(*args)
    process_job_command(nil, *args)
  rescue UnknownOption => e
    # Subcommand not known? Assume it is an inactive job ID
    jobid = args.first
    job = user.inactive_jobs.find { |j| j.id == jobid }
    return render('job' => job.to_h.stringify_keys) if job
    raise e
  end
  alias jobs job

  def process_job_command(jobs, *args)
    subcommand = args.first
    if subcommand && JOB_COMMANDS.include?(subcommand.downcase)
      # e.g., strip out unneccessary 'job'
      args = args[1..-1]
      args = [] if args.nil?
      subcommand = args.first
    end

    if INACTIVE_STATE_SUBCOMMANDS.include?(subcommand)
      return process_inactive_job_command(jobs, *args)
    end

    jobs ||= user.active_jobs

    if SHOW_ALL_SUBCOMMANDS.include?(subcommand)
      return render('jobs' => jobs.map { |job| job.to_h.stringify_keys })
    end

    return render(count: jobs.count) if subcommand == 'count'

    if ACTIVE_STATE_SUBCOMMANDS.include?(subcommand)
      return process_job_state_command(jobs, *args)
    end

    if ACCOUNT_COMMANDS.include?(subcommand.downcase)
      accounts = jobs.map(&:account).uniq
      return process_account_command(accounts, *args[1..-1])
    end

    job = jobs.find { |j| j.id == subcommand }
    return render('job' => job.to_h.stringify_keys) if job
    raise UnknownOption, subcommand
  end

  def process_inactive_job_command(jobs, *args)
    subcommand = args.first

    if jobs.nil?
      jobs = ClusterHelper::InactiveJob.user(user).all
    else
      job = jobs.first
      jobs = user.inactive_jobs if job.nil? || job.active?
    end
    jobs = jobs.select(&:completed?) if subcommand == 'completed'

    process_job_command(jobs, *args[1..-1])
  end

  def process_job_state_command(jobs, *args)
    subcommand = args.first

    if subcommand == 'running'
      jobs = jobs.select(&:running?)
    elsif subcommand == 'pending'
      jobs = jobs.select(&:pending?)
    end
    process_job_command(jobs, *args[1..-1])
  end

  def account(*args)
    process_account_command(user.accounts, *args)
  end
  alias accounts account

  def process_account_command(accounts, *args)
    subcommand = args.first

    if ['name', 'names'].include?(subcommand)
      return render('accounts' => accounts.map(&:name))
    end

    if ['all', nil].include?(subcommand)
      return render('accounts' => accounts.map { |a| a.to_h.stringify_keys })
    end

    if subcommand == 'members'
      return render('accounts' =>
                    accounts.map do |account|
                      { 'name' => account.name,
                        'members' => account.members.map(&:username) }
                    end)
    end

    if JOB_COMMANDS.include?(subcommand.downcase)
      jobs = ClusterHelper::ActiveJob.account(accounts).all
      return process_job_command(jobs, *args[1..-1])
    end

    accounts = accounts.select { |j| j.name.start_with?(subcommand) }
    return process_account_command(accounts, *args[1..-1]) if accounts

    raise UnknownOption
  end

  def switch_user(username = nil)
    @user = ClusterHelper::User.new(username || @options[:user])
  end

  def reload
    @user.reload
  end

end

JobConsole.new.run if $PROGRAM_NAME == __FILE__
