#!/usr/bin/env ruby

require_relative '../lib/cluster_helper'
require_relative '../lib/cluster_helper/monkey_patch/hash_stringify_keys'
require 'readline'

class JobConsole < ClusterHelper::BaseReportProgram

  COMMANDS = ['account', 'accounts',
              'job', 'jobs',
              'user', 'help',
              'quit', 'exit', 'q'].freeze

  config_option :user
  config_option :json
  config_option :compact_json
  config_option :yaml

  config_option :command

  private

  def options_command(opts)
    opts.on('-c', '--command COMMAND', 'Run command and exit') do |v|
      @options[:command] = v
    end
  end

  def print_help
    puts 'Some things to try:'
    puts '  jobs'
    puts '  jobs count'
    puts '  job 1112222333'
    puts '  jobs running (or pending)'
    puts '  accounts'
    puts '  account members'
    puts '  account def-howdy (or just match start of string)'
    puts '  help'
    puts 'Press Ctrl-D to exit.'
  end
  alias help print_help

  def main
    bnd = binding()
    if @options[:command]
      input_to_commands(@options[:command]).each do |command|
        break unless command
        bnd.eval command
      end
      return
    end

    print_help

    while (input = Readline.readline(prompt, true))
      begin
        input_to_commands(input).each do |command|
          return nil unless command
          bnd.eval command
        end
      rescue UnknownOption
        puts "Bad option (type 'help' for assistance)"
      rescue NameError
        puts "Bad command (type 'help' for assistance)"
      rescue StandardError => e
        puts "Error (#{e.class}) (type 'help' for assistance)"
      end
    end
    puts ''
  end

  def input_to_commands(input)
    input.strip.split(';').map { |i| sanitize_input(i) }
  end

  def sanitize_input(input)
    parts = input.split(' ')
    method = parts[0].strip
    raise NameError(method) unless COMMANDS.include?(method)
    if method == 'user'
      method = 'switch_user'
    elsif ['quit', 'exit', 'q'].include?(method)
      return nil
    end

    args = parts[1..-1].map { |value| "'#{value}'" }

    "#{method} #{args.join(', ')}"
  end

  def prompt
    "job_console(#{user.username})> "
  end

  def job(*args)
    process_job_command(user.jobs, *args)
  end
  alias jobs job

  def process_job_command(jobs, *args)
    subcommand = args.first

    if ['all', nil].include?(subcommand)
      return render('jobs' => jobs.map { |job| job.to_h.stringify_keys })
    end

    return render jobs.count if subcommand == 'count'

    if subcommand == 'running'
      jobs = jobs.select(&:running?)
      return process_job_command(jobs, *args[1..-1])
    end

    if subcommand == 'pending'
      jobs = jobs.select(&:pending?)
      return process_job_command(jobs, *args[1..-1])
    end

    if ['account', 'accounts'].include?(subcommand)
      accounts = jobs.map(&:account).uniq
      return process_account_command(accounts, *args[1..-1])
    end

    job = jobs.find { |j| j.id == subcommand }
    return render('job' => job.to_h.stringify_keys) if job
    raise UnknownOption
  end

  def account(*args)
    process_account_command(user.accounts, *args)
  end
  alias accounts account

  def process_account_command(accounts, *args)
    subcommand = args.first

    if ['name', 'names'].include?(subcommand)
      return render('accounts' => accounts.map(&:name))
    end

    if ['all', nil].include?(subcommand)
      return render('accounts' => accounts.map { |a| a.to_h.stringify_keys })
    end

    if subcommand == 'members'
      return render('accounts' =>
                    accounts.map do |account|
                      { 'name' => account.name,
                        'members' => account.members.map(&:username) }
                    end)
    end

    if ['job', 'jobs'].include?(subcommand)
      # TODO: try to make this handle multiple accounts
      jobs = ClusterHelper::Job.where(account: accounts.first)
      return process_job_command(jobs, *args[1..-1])
    end

    accounts = accounts.select { |j| j.name.start_with?(subcommand) }
    return process_account_command(accounts, *args[1..-1]) if accounts

    raise UnknownOption
  end

  def switch_user(username = nil)
    @user = ClusterHelper::User.new(username || @options[:user])
  end

end

JobConsole.new.run if $PROGRAM_NAME == __FILE__
